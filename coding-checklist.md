# Coding checklist

Date: 2016-08-13 12:46
Tags:[]
Categories:[]

---

## はじめに

### 概要

コーディング時のセルフチェックリストを記載する。以下を目的とする。

- コードレビューでの指摘軽減…コードレビューで同様の指摘を受けることを減らす
- コードレビュー時のディスコミュニケーション解消…指摘意図を説明する際などに使用する

### 方針

コーディング時に考慮しないといけないことを以下に大別する。

1. **Java言語一般**としての適切性
1. **Javaマルチスレッドプログラミング**としての適切性
1. コードスタイルや名前付けなどの**可読性**
1. リファクタリングで担保できるコードの**保守性**
1. **プロジェクトの基準**に従っているか
1. その他のレビューで**よく指摘されること**

それぞれ以下のデファクトといえる参考書籍をベースにチェックリストを作成する。
レビュー時に指摘を受けやすい箇所などの特に注意が必要な箇所を抜粋する。

1. Java言語一般
    - [EFFECTIVE JAVA 第2版 (The Java Series) : Joshua Bloch, 柴田 芳樹 : 本 : Amazon](https://www.amazon.co.jp/EFFECTIVE-JAVA-Java-Joshua-Bloch/dp/4621066056)
1. Javaマルチスレッドプログラミング
    - [Java並行処理プログラミング ―その「基盤」と「最新API」を究める― : Brian Goetz, Joshua Bloch, Doug Lea : 本 : Amazon.co.jp](https://www.amazon.co.jp/Java%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E2%80%95%E3%81%9D%E3%81%AE%E3%80%8C%E5%9F%BA%E7%9B%A4%E3%80%8D%E3%81%A8%E3%80%8C%E6%9C%80%E6%96%B0API%E3%80%8D%E3%82%92%E7%A9%B6%E3%82%81%E3%82%8B%E2%80%95-Brian-Goetz/dp/4797337206)
1. 可読性
    - [リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック (Theory in practice) : Dustin Boswell, Trevor Foucher, 須藤 功平, 角 征典 : 本 : Amazon.co.jp](https://www.amazon.co.jp/%E3%83%AA%E3%83%BC%E3%83%80%E3%83%96%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89-%E2%80%95%E3%82%88%E3%82%8A%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E3%81%9F%E3%82%81%E3%81%AE%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%A7%E5%AE%9F%E8%B7%B5%E7%9A%84%E3%81%AA%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF-Theory-practice-Boswell/dp/4873115655)
1. 保守性
    - [Amazon.co.jp: 新装版　リファクタリング　既存のコードを安全に改善する 電子書籍: Martin Fowler, 児玉公信・友野晶夫・平澤章・梅澤真史: Kindleストア](https://www.amazon.co.jp/dp/B01IGW5MG0/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1)
1. プロジェクトの基準
    - 参考書籍は特に無し
1. よく指摘されること
    - 参考書籍は特に無し

### 対象読者

- コーダ
- コーディングレビュア

### 注意点

- 画一的な大量のチェックリストはfalse positiveの問題を発生させる懸念がある。不要と判断した項目は適宜削除する。

## Java言語一般 (Based on "Effective Java")

以下の構成とする。

1. オブジェクトの生成と消滅
2. すべてのオブジェクトに共通のメソッド
3. クラスとインタフェース
4. ジェネリックス
5. enumとアノテーション
6. メソッド
7. プログラミング一般
8. 例外
9. 並行性
10. シリアライズ

### 1. オブジェクトの生成と消滅

#### [x] 不必要なオブジェクトの生成を避けているか

- 不変オブジェクトならランタイムに任せる
- オートボクシングによるラッパーインスタンス生成を回避する

Refs: [不必要なオブジェクトの生成を避ける - Strategic Choice](http://d.hatena.ne.jp/asakichy/20110928/1317161052)

### 2. すべてのオブジェクトに共通のメソッド

#### [x] cloneを注意してオーバーライドしているか

- cloneによる複製の実現は「とてつもなく複雑」である。
- 代替手段を使うか、複製の手段を提供しないほうが賢明である。

Refs: [cloneを注意してオーバーライドする - Strategic Choice](http://d.hatena.ne.jp/asakichy/20111024/1319407775)

### 3. クラスとインタフェース

#### [x] クラスとメンバーへのアクセス可能性を最小限にしているか

- 【どういうこと？　】
    - 原則、一旦privateで考えてみる。
- 【どうして？　】
    - publicにすると、完全に公開API。
    - protectedにすると、publicでなくても、もう公開API。
    - 公開APIは永久にサポートしなければならない。
- 【どうすれば？　】
    - パッケージプライベートは、公開APIではない。

Refs: [クラスとメンバーへのアクセス可能性を最小限にする - Strategic Choice](http://d.hatena.ne.jp/asakichy/20111027/1319666795)

#### [x] 可変性を最小限にしているか

可変にすべきかなり正当な理由がない限り、クラスは不変とする。

Refs: [可変性を最小限にする - Strategic Choice](http://d.hatena.ne.jp/asakichy/20111031/1320012492)

#### [x] 継承よりコンポジションを選択しているか

- 実装継承は本当にis-a関係の時だけ使用する。
- そうでない場合は、コンポジションを使用する。
- コンポジションは実装継承より「頑強」かつ「強力」なので。

Refs: [継承よりコンポジションを選ぶ - Strategic Choice](http://d.hatena.ne.jp/asakichy/20111101/1320098249)

### 4. ジェネリックス

#### [x] APIの柔軟性向上のために境界ワイルドカードを使用しているか

広く使用されるAPIには、使い勝手を考慮し、ワイルドカード型を適用する。

Refs: [APIの柔軟性向上のために境界ワイルドカードを使用する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20111121/1321827437)

### 5. enumとアノテーション

#### [x] int定数の代わりにenumを使用する

従来のintやStringによる定数型より、必ずenum型を使用すること。

Refs: [int定数の代わりにenumを使用する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20111128/1322432216)

### 6. メソッド

#### [x] メソッドのシグニチャを注意深く設計する

- 便利なメソッドを提供し過ぎない
- 長いパラメータのリストは避ける
- パラメータ型はクラスよりインタフェース
- パラメータはbooleanよりenum型

Refs: [メソッドのシグニチャを注意深く設計する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20111214/1323818748)

### 7. プログラミング一般

#### [x] インタフェースでオブジェクトを参照する

パラメータ、戻り値、変数、およびフィールドは、型を指定して宣言される。

Refs: [インタフェースでオブジェクトを参照する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20120111/1326232977)

### 8. 例外 [Important]

#### [x] 例外的状態にだけ例外を使用する

- 例外を通常のフローで使用しない。
- APIを作るときは、通常のフローでは例外を強要しない設計にする。

Refs: [例外的状態にだけ例外を使用する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20120120/1327011562)

#### [x] 回復可能な状態にはチェックされる例外を、プログラミングエラーには実行時例外を使用する

- チェックされる例外
    - 例外状態から回復可能な、「準」通常制御フローを表現する。
- チェックされない例外。
    - 大抵の場合、事前条件を満たしていないことによる実装のエラー。

Refs: [回復可能な状態にはチェックされる例外をプログラミングエラーには実行時例外を使用する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20120123/1327270465)

#### [x] 標準例外を使用する

JDKでも他のフレームワークでも、そのコンテキストで標準の例外を使用するのは、プログラムを読みやすくする1つの方法。

Refs: [標準例外を使用する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20120125/1327444161)

#### [x] 抽象概念に適した例外をスローする

- 上位レイヤAPIが行っている処理と関係のない例外は、使用側が混乱する。
- 上位レイヤAPIを実装の詳細で汚染することになる。

Refs: [抽象概念に適した例外をスローする - Strategic Choice](http://d.hatena.ne.jp/asakichy/20120126/1327529186)

### 9. 並行性

#### [x] 共有された可変データへのアクセスを同期する

- volatile修飾子付き変数
    - 変数アクセスの相互排他は行わないが、最後に書き込まれた値が見えることを保証する。
- 複数のスレツドが可変データを共有する場合には、そのデータを読み書きするスレッドは同期を行わなければならない。
- 並行プログラミングの障害原因調査は困難なので、実装方法はより安全志向で選択する。

Refs: [共有された可変データへのアクセスを同期する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20120203/1328220449)

#### [x] スレッド安全性を文書化する

- マルチスレッドで安全に使用してもらうため、クラスはサポートするスレッド安全性を明確に文書化しなければならない。

Refs: [スレッド安全性を文書化する - Strategic Choice](http://d.hatena.ne.jp/asakichy/20120209/1328739063)

## Javaマルチスレッドプログラミング (Based on Java並行処理プログラミング）

> スレッドが特殊で高度なプログラミング技法だった時代には、並行処理は"前衛的"な話題でした。
> しかし今は、ふつうのプログラマたちがスレッドの安全性（スレッドセーフ性）を意識しなければなりません。

以下の構成とする。

1. スレッドセーフ
2. オブジェクトを組み立てる
3. 並行処理の構築部材
4. キャンセルとシャットダウン

### 1. スレッドセーフ

#### [x] オブジェクトがスレッドセーフとなっているか

あるステート変数に複数のスレッドがアクセスし、どれかのスレッドが変数への書き込みをする可能性があるなら、
すべてのスレッドに対して、その変数へのアクセスを必ず同期化しなければなりません。

Refs: P.17

#### [x] アトミックに操作しているか

ステートに関連しているステート変数すべてを単一のアトミックな操作で更新していること。

Refs: P.22

#### [x] ステートをロックでガードしているか

複数のスレッドがアクセスする可変なステート変数は、
その変数への**すべての**アクセスが**同じ**ロックのもとに行われる必要があります。

**Note:** `@GuardedBy`アノテーションでドキュメント化するとよい。

Refs: P.32

### 2. オブジェクトを組み立てる

#### [x] 同期化ポリシーをドキュメント化しているか

- クラスのスレッドセーフ性の保証をクライアントのためにドキュメントしてください
- クラスの同期化ポリシーをメンテナンス担当者のためにドキュメントしてください

Refs: P.87

### 3. 並行処理の構築部材

#### [x] 同期化コレクションでなく並行コレクションを使用していること

Refs: P.97

### 4. キャンセルとシャットダウン

#### [x] キャンセル以外の目的にインタラプションを利用していないか

キャンセル以外の目的にインタラプションを使うとプログラムの安定性を損ない、
大きなアプリケーションは脆弱になりがちです。

Refs: P.157

#### [x] スレッドはインタラプションポリシーを持っているか

> スレッドのインタラプションポリシーを実装しているコードだけが、インタラプションリクエストをもみ消すことを許されます。

- `InterruptException`を理由なく握りつぶしていないか

Refs: P.160

#### [x] ExecutorServiceを適切にシャットダウンしているか

- `shutdown`と`shutdownNow`のそれぞれの特徴を理解し適切にシャットダウンすること。

Refs: P.175

#### [x] 未補足例外ハンドラでスレッドの異常終了をハンドリングしているか

長時間稼働するアプリケーションでは、すべてのスレッドに`UncaughtExceptionHandler`をセットして、少なくとも例外をログしてください。

Refs: P.184

## 可読性 (Based on "リーダーブルコード")

> コードは書く時間より圧倒的に「読む時間」のほうが大きい。
>
> コードは他の人が最短時間で理解できるように書かなければいけない。

以下の構成とする。

1. コードのルックス
    - 名前
    - コメント
2. コードのロジック
    - 制御フロー
    - 式の分割
    - 変数
3. コードの再構成
4. テストコード

### 1. コードのルックス

#### [x] 汎用的すぎる名前を使っていないか

`tmp`,`retval`,`result`などの汎用すぎる名前は避け、名前に**情報を詰め込む**こと。

Refs: [名前：汎用的な名前を避ける：retval - Strategic Choice](http://d.hatena.ne.jp/asakichy/20140624/1403560785)

#### [x] ブール値の名前は理解しやすいか

- 一般的には`is`,`has`が使用される
- 肯定形にしたほうが読みやすい

#### [x] 意味のないコメントを書いていないか

コードからすぐに分かることをコメントに書かない。

Refs: [コメント：コメントすべきでないこと：コードからすぐわかること - Strategic Choice](http://d.hatena.ne.jp/asakichy/20140806/1407276374)

#### [x] 高レベルなコメントを書いているか

クラス自体に対するコメント、クラスファイル間で該当のクラスはどのような役割を持っているかを説明する。

Refs: [コメント：コメントすべきこと：コードに対する考え - Strategic Choice](http://d.hatena.ne.jp/asakichy/20140818/1408317345)

#### [x] コードの意図をコメントしているか

あえて不規則なことをしている箇所などの、コードだけではわからない**意図**をコメントするべき。

Refs: [コメント：コメントすべきこと：定数の背景 - Strategic Choice](http://d.hatena.ne.jp/asakichy/20140820/1408490371)

### 2. コードのロジック

#### [x] ネストを浅くしているか

- ifを入れ子にしない→理由：コードを読む人は条件を精神的にスタックにPUSHしないといけないため。
- また、早めにreturnする「ガード節」をつくることでネストを浅くすることも検討すること。

Refs: [制御フロー：ネストを浅くする](http://d.hatena.ne.jp/asakichy/20140918/1410991414)

#### [x] 変数のスコープを縮めているか

「変数のことが見えるコード行数をできるだけ減らす」= スコープを縮める →理由：変数を追うために読むコードが大量になる。

Refs: [変数：スコープを縮める：プライベート変数](http://d.hatena.ne.jp/asakichy/20141008/1412719396)

#### [x] 変数は一度だけ書き込んでいるか

- 変数の生存期間（スコープ）が長いとコードが追いかけにくいという理由と同様に「変数がなんども値が変更されるとコードを追いかけにくい」という特性もある。
- 変更の必要のない変数は積極的にconst(C++)、final(Java)を使用する。

Refs: [変数：一度だけ書き込む - Strategic Choice](http://d.hatena.ne.jp/asakichy/20141015/1413323989)

### 3. コードの再構成

#### [x] 無関係の下位問題を抽出しているか

目的：プロジェクト固有のコードから汎用コードを分離する
メリット：汎用問題から切り離された境界線上の明確な業務固有の問題に集中できる

- 汎用コードは素晴らしい、プロジェクトから完全に切り離されているからだ。このようなコードは開発もテストも楽だ。すべてのコードがこうなればいいのに！
- このライブラリや言語にXYZの関数がればなぁと思ったらその関数を自分でかけばよい、それが汎用コードになる。

Refs: [無関係の下位問題の抽出 - Strategic Choice](http://d.hatena.ne.jp/asakichy/20141016/1413410677)

#### [x] 一度に1つのことのみしているか [Important]

一度に複数のことをするコードは理解しにくくなります。

Refs: [一度に一つ：タスクは小さく - Strategic Choice](http://d.hatena.ne.jp/asakichy/20141028/1414447184)

#### [x] 短いコードを書いているか

- 過剰な機能を持たせないようにします。

Refs: [コードを短く：過剰な機能を持たせない - Strategic Choice](http://d.hatena.ne.jp/asakichy/20141110/1415570416)

### 4. テストコード

#### [x] テスタビリティの高いコードとなっているか

Refs: [テストコード：本物コードはテストに優しく - Strategic Choice](http://d.hatena.ne.jp/asakichy/20141127/1417039745)

#### [x] テストコードはやりすぎていないか

- テストのために本物のコードの読みやすさを犠牲にしたり、テスト都合で本物のコードに手を加えない。
- カバレッジ100％にしないと気がすまないのはよくない。現実的にはカバレッジが100％になることはない。

Refs: [テストコード：テストをやりすぎない - Strategic Choice](http://d.hatena.ne.jp/asakichy/20141128/1417125937)

## 保守性 (Based on "リファクタリング")

### [x] コードに不吉な匂いが残っていないか

Refs: [コードの臭い・脱臭チャート - Strategic Choice](http://d.hatena.ne.jp/asakichy/20101130/1291078016)

## プロジェクトの基準

### [x] 例外処理は"例外設計基準"に従っているか

TODO

#### [x] ログ処理は"ログ出力基準"に従っているか

TODO

## TODOs

- [ ] 構成が、書籍ベースかカテゴリベースか、一貫性がない
- [ ] ↓らへんからも持ってこれないか
    - [Clean Code アジャイルソフトウェア達人の技 : Robert C. Martin, 花井 志生 : 本 : Amazon](https://www.amazon.co.jp/Clean-Code-%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%81%94%E4%BA%BA%E3%81%AE%E6%8A%80-Robert-Martin/dp/4048676881)
    - [Amazon.co.jp: 【電子合本版】Code Complete 第2版　完全なプログラミングを目指して 電子書籍: Steve McConnell: 本](https://www.amazon.co.jp/%E3%80%90%E9%9B%BB%E5%AD%90%E5%90%88%E6%9C%AC%E7%89%88%E3%80%91Code-Complete-%E7%AC%AC2%E7%89%88%E3%80%80%E5%AE%8C%E5%85%A8%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%82%92%E7%9B%AE%E6%8C%87%E3%81%97%E3%81%A6-Steve-McConnell-ebook/dp/B01E5DYK1C/ref=sr_1_2?s=books&ie=UTF8&qid=1471060491&sr=1-2&keywords=%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%97%E3%83%AA%E3%83%BC%E3%83%88)
- [ ] 「仕様との適合性」をチェックする項目がない
